---
title: "Analiza ofert dotyczących wynajmu nieruchomości z portalu gumtree.pl"
author: "Krzysztof Słomczyński"
date: "26 listopada 2016"
output: revealjs::revealjs_presentation
css: tuatara.css
# runtime: shiny
---

```{r setup, include = FALSE}
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
library(knitr)
opts_chunk$set(
    comment = "",
    fig.width = 12,
    echo = FALSE,
    eval = TRUE,
    message = FALSE,
    warning = FALSE,
    tidy.opts = list(
        keep.blank.line = TRUE,
        width.cutoff = 150
        ),
    options(width = 150)
)
```

```{r}
library(glmnet)
library(dplyr)
library(readr)
library(stringi)
library(shiny)
```

## Dlaczego taki temat?

- Praktyczny wymiar projektu
- [CzasDojazdu](http://github.com/mi2-warsaw/CzasDojazdu)
- Błędnie zapisywane dane (metraż), niektóre pomijane (palenie, zwierzęta, płeć)
- Udoskonalenie scrapera
- Zbudowanie modelu przewidującego ceny wynajmowanych pokojów

## Udoskonalenie scrapera - zdobycie danych

- Wykoszystanie pakietu `rvest` oraz wtyczki [SelectorGadget](http://selectorgadget.com)
- Baza danych SQLite a pliki *.csv
- Liczba ofert w czasie trwania projektu nie będzie duża

## Przygotowanie do projektu

Ukończenie kursów:

- Machine Learning at Coursera by Andrew Ng
- Statistical Learning at Stanford ONLINE by Trevor Hastie and Robert Tibshirani

Zapoznanie się z narzędziami:

- Hadoop HDFS
- Spark (pakiet `sparklyr`)
- Pakiety do różnego rodzaju regresji (`boot`, `leaps`, `glmnet`)
- Pakiety do tworzenia prezentacji `revealjs`

## Struktura danych dotyczących pokojów na portalu {.floatBullet}

Powtarzalne opcje wyboru:

1. Lokalizacja
    - Miasto, Województwo
2. Dostępny
    - Data w formacie %d/%m/%Y
3. Wielkość (m2)
    - Liczba typu Integer
4. Współdzielenie
    - Współdzielenie pokoju
    - Współdzielenie mieszkania/domu
5. Do wynajęcia przez
    - "---------"
    - Właściciel
    - Agencja
6. Palący
    - "---------""
    - Tak
    - Nie
7. Przyjazne zwierzakom
    - "---------""
    - Tak
    - Nie
8. Cena
    - Liczba typu Integer
    - Proszę o kontakt
    - Wymiana/zamiana
9. Rodzaj nieruchomości
    - "---------"
    - Mieszkanie
    - Dom
    - Inne
10. Preferowana płeć
    - "---------"
    - Mężczyzna
    - Kobieta
    - Bez preferencji
11. Liczba pokoi
    - "---------"
    - Kawalerka lub garsoneria
    - 2 pokoje
    - 3 pokoje
    - 4 pokoje
    - 5 pokoi
    - 6 lub więcej pokoi
 
## Przegląd danych

```{r}
pokoje <- read_csv("pokoje.csv")

pokoje <-
  pokoje %>%
  mutate(
    lokalizacja = lokalizacja %>%
      stri_replace_first_regex(", Warszawa", "") %>%
      as.factor(),
    do_wynajecia_przez = do_wynajecia_przez %>% as.factor(),
    wspoldzielenie = wspoldzielenie %>% as.factor(),
    liczba_pokoi = liczba_pokoi %>% as.factor(),
    rodzaj_nieruchomosci = rodzaj_nieruchomosci %>% as.factor(),
    preferowana_plec = preferowana_plec %>% as.factor(),
    palacy = palacy %>% as.factor(),
    przyjazne_zwierzakom = przyjazne_zwierzakom %>% as.factor()
  )

summary(pokoje)
```

## Cena a wielkość

```{r}
plot(cena~wielkosc, pokoje)
```

## Cena a wielkość - regresja

```{r}
sprawdzenie01 <-
  pokoje %>%
  filter(
    between(cena, 100, 1000),
    between(wielkosc, 10, 30)
  )

plot(cena~wielkosc, sprawdzenie01)
fit01 <- lm(cena~wielkosc, sprawdzenie01)
abline(fit01, col = "red", lwd = 2)
```

## Cena a wielkość - problemy

- Nieintuicyjnie cena pokojów do wynajęcia spada wraz ze wzrostem metrażu
- Niekonsekwencja we wprowadzaniu danych przez oferantów
- Raz podany metraż całego mieszkania z ceną za pokój
- Innym razem podany metraż pokoju z ceną za wszystkie pokoje

## Cena a wielkość - wnioski

- Wyrafinowana analiza treści opisu
- Propozycja dokładnego opisu atrybutów w formularzu na [gumtree.pl](gumtree.pl)

## Mieszkania i domy

- Ponad 30 tysięcy ofert w danej chwili
- Dla Warszawy 13 tysięcy
- Wcześniej - `parking` oraz `liczba_lazienek`
- Teraz - `wspoldzielenie` oraz `preferowana_plec`

## Przegląd danych

```{r}
mieszkania <- read_csv("mieszkania.csv")

mieszkania <-
  mieszkania %>%
  mutate(
    lokalizacja = lokalizacja %>%
      stri_replace_first_regex(", Warszawa", "") %>%
      as.factor(),
    do_wynajecia_przez = do_wynajecia_przez %>% as.factor(),
    parking = parking %>% as.factor(),
    liczba_pokoi = liczba_pokoi %>% as.factor(),
    rodzaj_nieruchomosci = rodzaj_nieruchomosci %>% as.factor(),
    liczba_lazienek = liczba_lazienek %>% as.factor(),
    palacy = palacy %>% as.factor(),
    przyjazne_zwierzakom = przyjazne_zwierzakom %>% as.factor()
  )

summary(mieszkania)
```

## Cena a wielkość

```{r}
plot(cena~wielkosc, mieszkania)
```

## Cena a wielkość - regresja

```{r}
dane <-
  mieszkania %>%
  select(-opis) %>%
  filter(
    between(cena, 1000, 5000),
    between(wielkosc, 20, 100)
  )

fit11 <- lm(cena~wielkosc, dane)
summary(fit11)
```

## Cena a wielkość - regresja

```{r}
plot(cena~wielkosc, dane)
abline(fit11, col = "red", lwd = 2)
```

## Udział pozostałych predyktorów

```{r}
fit12 <-
  lm(cena~., dane)
summary(fit12)
```

## Wielomiany

```{r}
fit21 <-
  lm(cena~wielkosc+I(wielkosc^2), dane)
fit22 <-
  lm(cena~poly(wielkosc, 6), dane)
summary(fit22)
```

## Wielomiany

```{r}
plot(cena~wielkosc, dane)
abline(fit11, col = "red", lwd = 2)
points(dane$wielkosc, fitted(fit21), col = "blue", pch = 20)
points(dane$wielkosc, fitted(fit22), col = "green", pch = 20)
legend(
  "topleft",
  legend = c(1, 2, 6),
  col = c("red", "blue", "green"),
  pch = 19
)
```

## LOOCV - wyznaczanie błędu

- Biblioteka `boot`
- `LOOCV` czyli `Leave One Out Cross Validation`
- Tyle modeli ile obserwacji (pomija jedeną)
- Błąd na podstawie różnic między pominiętymi obserwacjami a ich przewidzeniem
- Delta (cały zbiór; poprawka o pominięcie)
- Efekt bardziej widoczny dla K krotnej kroswalidacji.

## LOOCV - wyznaczanie błędu

- Powolna metoda cv.glm
- Formuła uwzględniająca wpływ i-tej obserwacji na dopasowanie do niej krzywej
- Kilka minut vs kilka sekund
- Nie funkcjonuje ona w wypadku regresji logistycznej

## K-fold - wyznaczanie błędu

- K modeli (najpopularniejsze 5 i 10)
- Znacznie mniej obliczeń - szybsze działanie
- Różnica niewielka - bardziej stablina, miarodajna metoda

## Kolejne stopnie wielomianów

```{r}
library(boot)

loocv.glm <-
  function(fit) {
    h <- lm.influence(fit)$h
    mean((residuals(fit)/(1-h))^2)
  }

cvBlad <- rep(0, 6)
stopien <- 1:6
for (d in stopien) {
  fit32 <- glm(cena~poly(wielkosc, d), data = dane)
  cvBlad[d] <- loocv.glm(fit32)
}

cvBladK10 <-
  stopien %>%
  sapply(
    function(x) {
      cv.glm(dane, fit32, K = 10)$delta[1]
    }
  )

plot(stopien, cvBlad %>% sqrt(), type = "b",  col = "red")
lines(stopien, cvBladK10 %>% sqrt(), type = "b", col = "blue")
legend(
  "topright",
  legend = c("LOOCV", "K-fold"),
  col = c("red", "blue"),
  pch = 19
)
```

## Dobór modelu z wieloma predyktorami

Wcześniej - jaki stopień wielomianu jednego predyktora?
Teraz - odpowiedni model z wieloma predyktorami

## Best Subset Regression

- Biblioteka `leaps`
- Porównuje wszytkie możliwe modele regresji o wszystkich możliwych rozmiarach
- Brak zagnieżdzania podgrup predyktorów
- Wykonuje ${2^p}$ modeli, gdzie p to liczba predyktorów
- Nasz przypadek - $2^{11}$ czyli 2048

## Best Subset Regression

```{r}
library(leaps)

fit41 <- regsubsets(cena~., dane, nvmax = 11)
sum41 <- summary(fit41)
sum41
```

## Best Subset Regression

```{r}
coef(fit41, 11)
```

## Best Subset Regression

```{r}
plot(sum41$cp, xlab = "Liczba predyktorów", ylab = "Cp", type = "b")
points(11, sum41$cp[11], pch = 20, col = "red")
```

## Best Subset Regression

```{r}
plot(fit41, scale = "Cp")
```

## Best Subset Regression

- W tym wypadku nie widać niezagnieżdzania
- Najmniejszy błąd dla największej liczby predyktorów
- Nie musiało tak być

## Forward Stepwise Selection

- "Chciwa" metoda - zagnieżdzanie podzbiorów predyktorów
- Raz dobrany czynnik wykorzystywany w następnym modelu
- Wykonuje około $\frac{p^2}{2}$ modeli
- Nasz przypadek to około 60 - tylko 3% poprzednich

## Backward Stepwise Selection

- Start ze wszystkimi predyktorami w modelu
- Odejmowanie najmniej wpływowego czynnika
- Nie można użyć na danych, gdzie m<p

## Walidacja - pojedyncza i K-krotna

- Dzielenie obserwacji na zestawy - treningowy i walidacyjny

```{r}
set.seed(44)
trening44 <- sample(1:nrow(dane), 9000)
fit44 <- regsubsets(cena~., dane[trening44, ], nvmax = 11, method = "forward")

test44 <- model.matrix(cena~., dane[-trening44, ])
valBlad <-
  1:length(dane) %>%
  sapply(
    function(x) {
      coefi <- coef(fit44, id = x)
      pred <- test44[, names(coefi)]%*%coefi
      mean((dane$cena[-trening44]-pred)^2)
    }
  )

predict.regsubsets <-
  function(obiekt, dane, id, ...) {
    form <- as.formula(obiekt$call[[2]])
    mat <- model.matrix(form, dane)
    coefi <- coef(obiekt, id = id)
    mat[, names(coefi)]%*%coefi
  }

set.seed(45)
folds <- sample(rep(1:10, length = nrow(dane)))
cvBledy <- matrix(NA, 10, 11)
for (k in 1:10) {
  best.fit <- regsubsets(cena~., dane[folds!=k, ], nvmax = 11, method = "forward")
  for (i in 1:length(dane)) {
    pred <- predict.regsubsets(best.fit, dane[folds==k, ], id = i)
    cvBledy[k, i] <- mean((dane$cena[folds==k]-pred)^2)
  }
}
rmse.cv <- sqrt(apply(cvBledy, 2, mean))
```

## Walidacja - pojedyncza i K-krotna

```{r}
plot(
  sqrt(valBlad),
  ylim = c(400, 900),
  xlab = "Rozmiar modelu",
  ylab = "Średnia kwadratowa błędów",
  pch = 19,
  type = "b"
)
points(sqrt(fit44$rss[-1]/9000), col = "red", pch = 19, type = "b")
points(rmse.cv, col = "blue", pch = 19, type = "b")
legend(
  "topright",
  legend = c("10 krotna Kroswalidacja", "Trening", "Walidacja"),
  col = c("blue", "red", "black"),
  pch = 19
)
```

## Ridge Regression (Regularyzacja Tichonowa)

- Biblioteka `glmnet` (dzielenie danych na predyktory i odpowiedzi)
- Człon regularyzacji w równaniu ($\lambda$ i $\mathcal{B}^2$)
- Duża $\lambda$ - małe $\mathcal{B}$
- Wszystkie predyktory
- Minimalizacja współczynników $\mathcal{B}$
- Normalizacja danych

## Ridge Regression (Regularyzacja Tichonowa)

```{r}
library(glmnet)

x <- model.matrix(cena~.-1, dane)
y <- dane$cena

fit45 <- glmnet(x, y, alpha = 0)
plot(fit45, xvar = "lambda", label = TRUE)
```

## Ridge Regression (Regularyzacja Tichonowa)

```{r}
plot(fit45, xvar = "dev", label = TRUE)
```

## Ridge Regression (Regularyzacja Tichonowa)

```{r}
cvRidge <- cv.glmnet(x, y, alpha = 0)
plot(cvRidge)
```

## Ridge Regression (Regularyzacja Tichonowa)

```{r}
daneNorm <-
  dane %>%
  mutate(
    cena = (cena-mean(cena))/max(cena),
    wielkosc = (wielkosc-mean(wielkosc))/max(wielkosc),
    liczba_wyrazow = (liczba_wyrazow-mean(liczba_wyrazow))/max(liczba_wyrazow)
  )

xn <- model.matrix(cena~.-1, daneNorm)
yn <- daneNorm$cena

fit45 <- glmnet(xn, yn, alpha = 0)
plot(fit45, xvar = "lambda", label = TRUE)
```

## Ridge Regression (Regularyzacja Tichonowa)

```{r}
plot(fit45, xvar = "dev", label = TRUE)
```

## Ridge Regression (Regularyzacja Tichonowa)

```{r}
cvRidge <- cv.glmnet(xn, yn, alpha = 0)
plot(cvRidge)
```

## Lasso

- `Least Absolute Shrinkage and Selection Operator`
- Element regulujący $|\mathcal{B}|$
- Współczynniki $\mathcal{B}$ sprowadzone do zera
- Część predyktorów nie bierze udziału

## Lasso

```{r}
fit46 <- glmnet(x, y)
plot(fit46, xvar = "lambda", label = TRUE)
```

## Lasso

```{r}
plot(fit46, xvar = "dev", label = TRUE)
```

## Lasso

```{r}
cvLasso <- cv.glmnet(x, y)
plot(cvLasso)
```

## Lasso

```{r}
fit47 <- glmnet(xn, yn)
plot(fit47, xvar = "lambda", label = TRUE)
```

## Lasso

```{r}
plot(fit47, xvar = "dev", label = TRUE)
```

## Lasso

```{r}
cvLassoN <- cv.glmnet(xn, yn)
plot(cvLassoN)
```

## Lasso

```{r}
(coef(cvLassoN) %>% as.vector() != 0) %>% sum()
```

## Walidacja - dobranie parametru $\lambda$

```{r}
lasso.tr <- glmnet(x[trening44, ], y[trening44])
lasso.tr
pred <- predict(lasso.tr, x[-trening44, ])
rmse <- sqrt(apply((y[-trening44]-pred)^2, 2, mean))
```

## Walidacja - dobranie parametru $\lambda$

```{r}
plot(log(lasso.tr$lambda), rmse, type = "b", xlab = "Log(lambda)")
```

## Walidacja - dobranie parametru $\lambda$

- Wcześniej
$log(\lambda_{min}) < 0$ oraz $log(\lambda_{1st}) \simeq 2.7$

- Teraz

```{r}
lam.best <- lasso.tr$lambda[order(rmse)[1]]
lam.best
lam.best %>% log()
```

## Walidacja - dobranie parametru $\lambda$

```{r}
coef(lasso.tr, s = lam.best)
```

## Aplikacja

Niestety, ten format prezentacji nie obsługuje uruchamiania aplikacji Shiny.

<!-- ## Aplikacja -->

<!-- ```{r} -->
<!-- dane <- read_csv("dane.csv") -->
<!-- model <- get(load("model.Rda")) -->
<!-- cvLasso <- get(load("cvLasso.Rda")) -->
<!-- iMin <- which(cvLasso$lambda == cvLasso$lambda.min) -->
<!-- iSE <- which(cvLasso$lambda == cvLasso$lambda.1se) -->

<!-- dane <- -->
<!--   dane %>% -->
<!--   mutate( -->
<!--     lokalizacja = lokalizacja %>% -->
<!--       stri_replace_first_regex(", Warszawa", "") %>% -->
<!--       as.factor(), -->
<!--     do_wynajecia_przez = do_wynajecia_przez %>% as.factor(), -->
<!--     parking = parking %>% as.factor(), -->
<!--     liczba_pokoi = liczba_pokoi %>% as.factor(), -->
<!--     rodzaj_nieruchomosci = rodzaj_nieruchomosci %>% as.factor(), -->
<!--     liczba_lazienek = liczba_lazienek %>% as.factor(), -->
<!--     palacy = palacy %>% as.factor(), -->
<!--     przyjazne_zwierzakom = przyjazne_zwierzakom %>% as.factor() -->
<!--   ) -->
<!-- ``` -->

<!-- <!-- <div style="margin-left:-50px; margin-top:-25px; width:150%"> -->
<!-- ```{r} -->
<!-- shinyApp( -->
<!--   shinyUI( -->
<!--     fluidPage( -->
<!--       fluidRow( -->
<!--         column( -->
<!--           3, -->
<!--           selectInput( -->
<!--             "lokalizacja", -->
<!--             "Lokalizacja:", -->
<!--             dane$lokalizacja %>% levels() -->
<!--           ) -->
<!--         ), -->
<!--         column( -->
<!--           3, -->
<!--           selectInput( -->
<!--             "liczba_pokoi", -->
<!--             "Liczba pokoi:", -->
<!--             dane$liczba_pokoi %>% levels() -->
<!--           ) -->
<!--         ), -->
<!--         column( -->
<!--           3, -->
<!--           selectInput( -->
<!--             "liczba_lazienek", -->
<!--             "Liczba łazienek:", -->
<!--             dane$liczba_lazienek %>% levels() -->
<!--           ) -->
<!--         ), -->
<!--         column( -->
<!--           2, -->
<!--           selectInput( -->
<!--             "do_wynajecia_przez", -->
<!--             "Do wynajęcia przez:", -->
<!--             dane$do_wynajecia_przez %>% levels() -->
<!--           ) -->
<!--         ) -->
<!--       ), -->
<!--       fluidRow( -->
<!--         column( -->
<!--           2, -->
<!--           numericInput( -->
<!--             "wielkosc", -->
<!--             "Wielkość (m2):", -->
<!--             dane$wielkosc %>% summary() %>% .[3], -->
<!--             dane$wielkosc %>% min(), -->
<!--             dane$wielkosc %>% max() -->
<!--           ) -->
<!--         ), -->
<!--         column( -->
<!--           3, -->
<!--           selectInput( -->
<!--             "rodzaj_nieruchomosci", -->
<!--             "Rodzaj nieruchomości:", -->
<!--             dane$rodzaj_nieruchomosci %>% levels() -->
<!--           ) -->
<!--         ), -->
<!--         column( -->
<!--           2, -->
<!--           selectInput( -->
<!--             "parking", -->
<!--             "Parking:", -->
<!--             dane$parking %>% levels() -->
<!--           ) -->
<!--         ), -->
<!--         column( -->
<!--           2, -->
<!--           selectInput( -->
<!--             "palacy", -->
<!--             "Palący:", -->
<!--             dane$palacy %>% levels() -->
<!--           ) -->
<!--         ), -->
<!--         column( -->
<!--           3, -->
<!--           selectInput( -->
<!--             "przyjazne_zwierzakom", -->
<!--             "Przyjazne zwierzakom:", -->
<!--             dane$przyjazne_zwierzakom %>% levels() -->
<!--           ) -->
<!--         ) -->
<!--       ), -->
<!--       fluidRow( -->
<!--         column( -->
<!--           3, -->
<!--           textAreaInput( -->
<!--             "opis", -->
<!--             "Opis:", -->
<!--             readLines("overlook.txt"), -->
<!--             "440%", -->
<!--             "220px" -->
<!--           ) -->
<!--         ) -->
<!--       ), -->
<!--       fluidRow( -->
<!--         column( -->
<!--           8, -->
<!--           htmlOutput("propozycja") -->
<!--         ) -->
<!--       ) -->
<!--     ) -->
<!--   ), -->
<!--   shinyServer( -->
<!--     function(input, output, session) { -->
<!--       wycena <- -->
<!--         eventReactive( -->
<!--           c( -->
<!--             input$lokalizacja, -->
<!--             input$do_wynajecia_przez, -->
<!--             input$rodzaj_nieruchomosci, -->
<!--             input$wielkosc, -->
<!--             input$liczba_pokoi, -->
<!--             input$liczba_lazienek, -->
<!--             input$parking, -->
<!--             input$palacy, -->
<!--             input$przyjazne_zwierzakom, -->
<!--             input$opis -->
<!--           ), -->
<!--           { -->
<!--             df <- -->
<!--               data_frame( -->
<!--                 cena = 1, -->
<!--                 lokalizacja = input$lokalizacja %>% -->
<!--                   factor(dane$lokalizacja %>% levels()), -->
<!--                 do_wynajecia_przez = input$do_wynajecia_przez %>% -->
<!--                   factor(dane$do_wynajecia_przez %>% levels()), -->
<!--                 liczba_pokoi = input$liczba_pokoi %>% -->
<!--                   factor(dane$liczba_pokoi %>% levels()), -->
<!--                 rodzaj_nieruchomosci = input$rodzaj_nieruchomosci %>% -->
<!--                   factor(dane$rodzaj_nieruchomosci %>% levels()), -->
<!--                 wielkosc = input$wielkosc, -->
<!--                 parking = input$parking %>% -->
<!--                   factor(dane$parking %>% levels()), -->
<!--                 liczba_lazienek = input$liczba_lazienek %>% -->
<!--                   factor(dane$liczba_lazienek %>% levels()), -->
<!--                 palacy = input$palacy %>% -->
<!--                   factor(dane$palacy %>% levels()), -->
<!--                 przyjazne_zwierzakom = input$przyjazne_zwierzakom %>% -->
<!--                   factor(dane$przyjazne_zwierzakom %>% levels()), -->
<!--                 liczba_wyrazow = input$opis %>% stri_count_words() -->
<!--               ) -->
<!--             mat <- model.matrix(cena~.-1, df) -->
<!--             pred <- predict(model, mat) -->
<!--             HTML( -->
<!--               paste( -->
<!--                 paste0( -->
<!--                   "Model o najmniejszym błędzie sugeruje cenę wynajmu: ", -->
<!--                   "<font color=\"#FF0000\"><b>", -->
<!--                   pred[iMin+1] %>% round(), -->
<!--                   "</b></font>", -->
<!--                   " PLN" -->
<!--                 ), -->
<!--                 paste0( -->
<!--                   "Elastyczniejszy model sugeruje cenę wynajmu: ", -->
<!--                   "<font color=\"#00FF00\"><b>", -->
<!--                   pred[iSE+1] %>% round(), -->
<!--                   "</b></font>", -->
<!--                   " PLN" -->
<!--                 ), -->
<!--                 sep = "<br/>" -->
<!--               ) -->
<!--             ) -->
<!--           } -->
<!--         ) -->
<!--       output$propozycja <- renderText(wycena()) -->
<!--     } -->
<!--   ) -->
<!-- ) -->
<!-- ``` -->

## Kod i inne projekty

- Kod napisany na potrzeby tego projektu na [github](http://github.com/krzyslom/tuatara)
- [Raport](http://mi2.mini.pw.edu.pl:3838/pracuj/ml) z innego projektu w którym brałem udział

Dziękuję za uwagę